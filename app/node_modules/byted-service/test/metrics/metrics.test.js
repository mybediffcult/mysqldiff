const should = require('should');
const { Metrics } = require('../../');

const METRIC_HOST = '10.11.40.199';
const METRIC_PORT = 9123;
const METRIC_PREFIX = 'ies.fe';

const delay = function(ms) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, ms)
  });
}

describe('metrics/metrics', () => {
  describe('#_send', () => {
    let metrics;

    before(() => {
      metrics = new Metrics({
        host: METRIC_HOST,
        port: METRIC_PORT,
        defaultPrefix: METRIC_PREFIX,
        bufferSize: 1
      });
    });

    it('should throws when argument is not an array', async () => {
      metrics._send.should.throw('invalid argument metrics: undefined, an array is expected');      
      metrics._send.bind(metrics, null).should.throw('invalid argument metrics: null, an array is expected');     
      metrics._send.bind(metrics, 1).should.throw('invalid argument metrics: 1, an array is expected'); 
      metrics._send.bind(metrics, '1').should.throw('invalid argument metrics: 1, an array is expected'); 
      metrics._send.bind(metrics, false).should.throw('invalid argument metrics: false, an array is expected'); 
      metrics._send.bind(metrics, {}).should.throw('invalid argument metrics: [object Object], an array is expected'); 
    });

    it('should return a promise resolved with undfined when argument is correct', async () => {
      const res = metrics._send([['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ]]);
      res.should.be.a.Promise();
      res.should.be.fulfilled(undefined);
    });
  });

  describe('#_flush', () => {
    let metrics;

    before(() => {
      metrics = new Metrics({
        host: METRIC_HOST,
        port: METRIC_PORT,
        defaultPrefix: METRIC_PREFIX,
        bufferSize: 10
      });

      metrics._buffer = [
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ]
      ];
    });

    it('should clear the buffer', async () => {
      await metrics._flush();
      metrics._buffer.should.be.an.Array();
      metrics._buffer.length.should.equal(0);      
    });

    it('should return a promise resolved with undefined', async () => {
      const res = metrics._flush();
      res.should.be.a.Promise();
      res.should.be.fulfilledWith(undefined);
    });
  });

  describe('#_flushIfNeeded', () => {
    let metrics;

    before(() => {
      metrics = new Metrics({
        host: METRIC_HOST,
        port: METRIC_PORT,
        defaultPrefix: METRIC_PREFIX,                
        bufferSize: 5,
        flushInterval: 1000
      });      
    });

    it('should not flush if buffer size is not greater than bufferSize specified in options', async () => {
      metrics._buffer = [        
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],                 
      ];
      const res = metrics._flushIfNeeded();      
      if(res instanceof Promise) {
        await res;
      }          
      metrics._buffer.should.be.an.Array();
      metrics._buffer.length.should.equal(4);            
    });

    it('should flush if buffer size is greater than bufferSize specified in options', async () => {
      metrics._buffer = [
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],          
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],                   
      ];
      const res = metrics._flushIfNeeded();          
      if(res instanceof Promise) {        
        await res;
      }
      metrics._buffer.should.be.an.Array();
      metrics._buffer.length.should.equal(0);
    });

    it('should flush after flushInterval', async () => {
      metrics._buffer = [
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],
        ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '1','name=yaphet','' ],                  
      ];
      const res = metrics._flushIfNeeded();      
      if(res instanceof Promise) {
        await res;
      }
      await delay(1200);
      metrics._buffer.should.be.an.Array();
      metrics._buffer.length.should.equal(0);
    });
  });

  describe('#_addToBuffer', () => {
    let metrics;

    before(() => {
      metrics = new Metrics({
        host: METRIC_HOST,
        port: METRIC_PORT,
        defaultPrefix: METRIC_PREFIX,
        bufferSize: 5
      });      
    });

    it('should throws when argument is not correct', async () => {
      metrics._addToBuffer.should.throw(`invalid argument metric: undefined, an array is expected`);      
      metrics._addToBuffer.bind(metrics, null).should.throw(`invalid argument metric: null, an array is expected`); 
      metrics._addToBuffer.bind(metrics, 1).should.throw(`invalid argument metric: 1, an array is expected`);       
      metrics._addToBuffer.bind(metrics, false).should.throw(`invalid argument metric: false, an array is expected`); 
      metrics._addToBuffer.bind(metrics, {}).should.throw(`invalid argument metric: [object Object], an array is expected`); 
      metrics._addToBuffer.bind(metrics, []).should.throw(`invalid argument metric: , length is expected to be 6`);       
      metrics._addToBuffer.bind(metrics, ['', 2, 3, 4, 5, 6]).should.throw(`invalid argument metric: ,2,3,4,5,6, element at index 0 is expected to be 'emit'`);
      metrics._addToBuffer.bind(metrics, ['emit', 'Counter', 3, 4, 5, 6]).should.throw(`invalid argument metric: emit,Counter,3,4,5,6, element at index 1 is expected to be 'couter', 'timer' or 'store'`);       
      metrics._addToBuffer.bind(metrics, ['emit', 'Timer', 3, 4, 5, 6]).should.throw(`invalid argument metric: emit,Timer,3,4,5,6, element at index 1 is expected to be 'couter', 'timer' or 'store'`);       
      metrics._addToBuffer.bind(metrics, ['emit', 'Store', 3, 4, 5, 6]).should.throw(`invalid argument metric: emit,Store,3,4,5,6, element at index 1 is expected to be 'couter', 'timer' or 'store'`);       
      metrics._addToBuffer.bind(metrics, ['emit', 'counter', '', 4, 5, 6]).should.throw(`invalid argument metric: emit,counter,,4,5,6, element at index 2 is expected to be non-empty`);       
      metrics._addToBuffer.bind(metrics, ['emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', '', 5, 6]).should.throw(`invalid argument metric: emit,counter,ies.fe.byted-service.metrics.test.from.local,,5,6, element at index 3 is expected to be non-empty`);             
    });

    it('should add metric to buffer', async () => {      
      const metric = [
        'emit', 'counter', 'ies.fe.byted-service.metrics.test.from.local', 1, 'name=yaphet', ''
      ];
      metrics._addToBuffer(metric);
      metrics._buffer.should.be.an.Array();
      metrics._buffer.length.should.equal(1);
      metrics._buffer[0].should.deepEqual(metric);      
    });    
  });

  describe('#_serializeTags', () => {
    let metrics;

    before(() => {
      metrics = new Metrics({
        host: METRIC_HOST,
        port: METRIC_PORT,
        defaultPrefix: METRIC_PREFIX,
        bufferSize: 5
      });      
    });

    it('should throws when argument is not correct', async () => {
      metrics._serializeTags.should.throw(`invalid argument tags: undefined, an object is expected`);      
      metrics._serializeTags.bind(metrics, null).should.throw(`invalid argument tags: null, an object is expected`); 
      metrics._serializeTags.bind(metrics, 1).should.throw(`invalid argument tags: 1, an object is expected`);            
      metrics._serializeTags.bind(metrics, false).should.throw(`invalid argument tags: false, an object is expected`);            
      metrics._serializeTags.bind(metrics, []).should.throw(`invalid argument tags: , an object is expected`);            
      metrics._serializeTags.bind(metrics, '1').should.throw(`invalid argument tags: 1, an object is expected`);            
    });
    
    it('should return correct serialized tags', async () => {
      const tags = {a: 1, b: 2, c: 3};
      let res = metrics._serializeTags(tags);         
      res.should.equal('a=1|b=2|c=3');
      res = metrics._serializeTags({});
      res.should.equal('');
    });
  });

  describe('#_getPrefixedName', () => {
    let metrics;

    before(() => {
      metrics = new Metrics({
        host: METRIC_HOST,
        port: METRIC_PORT,
        defaultPrefix: METRIC_PREFIX,
        bufferSize: 5
      });      
    });

    it('should return correct prefixed name', async () => {
      let prefixedName;
      const name = 'byted-service.metrics.couter.test.from.local';
      prefixedName = metrics._getPrefixedName(name);
      prefixedName.should.equal(`${METRIC_PREFIX}.${name}`);
      prefixedName = metrics._getPrefixedName(name, 'toutiao');
      prefixedName.should.equal(`toutiao.${name}`);
    });
  });

  describe('#_getMetric', () => {
    let metrics;

    before(() => {
      metrics = new Metrics({
        host: METRIC_HOST,
        port: METRIC_PORT,
        defaultPrefix: METRIC_PREFIX,
        bufferSize: 5
      });      
    });

    it('should throws when argument is not correct', async () => {
      metrics._getMetric.should.throw(`invalid argument metricType: undefined, 'couter', 'timer' or 'store' are expected`);      
      metrics._getMetric.bind(metrics, 1).should.throw(`invalid argument metricType: 1, 'couter', 'timer' or 'store' are expected`); 
      metrics._getMetric.bind(metrics, 'Counter').should.throw(`invalid argument metricType: Counter, 'couter', 'timer' or 'store' are expected`); 
      metrics._getMetric.bind(metrics, 'Timer').should.throw(`invalid argument metricType: Timer, 'couter', 'timer' or 'store' are expected`); 
      metrics._getMetric.bind(metrics, 'Store').should.throw(`invalid argument metricType: Store, 'couter', 'timer' or 'store' are expected`); 
      metrics._getMetric.bind(metrics, false).should.throw(`invalid argument metricType: false, 'couter', 'timer' or 'store' are expected`); 
      metrics._getMetric.bind(metrics, {}).should.throw(`invalid argument metricType: [object Object], 'couter', 'timer' or 'store' are expected`);             
      
      metrics._getMetric.bind(metrics, 'counter').should.throw(`invalid argument name: undefined, a non-empty string is expected`);
      metrics._getMetric.bind(metrics, 'counter', null).should.throw(`invalid argument name: null, a non-empty string is expected`);
      metrics._getMetric.bind(metrics, 'counter', {}).should.throw(`invalid argument name: [object Object], a non-empty string is expected`);
      metrics._getMetric.bind(metrics, 'counter', []).should.throw(`invalid argument name: , a non-empty string is expected`);
      metrics._getMetric.bind(metrics, 'counter', false).should.throw(`invalid argument name: false, a non-empty string is expected`);
      metrics._getMetric.bind(metrics, 'counter', 1).should.throw(`invalid argument name: 1, a non-empty string is expected`);

      metrics._getMetric.bind(metrics, 'counter', 'name').should.throw(`invalid argument value: undefined, a non-empty value is expected`);
      metrics._getMetric.bind(metrics, 'counter', 'name', null).should.throw(`invalid argument value: null, a non-empty value is expected`);
      metrics._getMetric.bind(metrics, 'counter', 'name', '').should.throw(`invalid argument value: , a non-empty value is expected`);                      
    });

    it('should return correct metric', async () => {     
      let metric;
      const name = 'byted-service.metrics.couter.test.from.local';
      metric = metrics._getMetric('counter', name, 1, 'toutiao', { a: 1, b: 2, c: 3 });
      metric.should.deepEqual([
        'emit', 'counter', `toutiao.${name}`, '1', 'a=1|b=2|c=3', ''
      ]);
       
      metric = metrics._getMetric('counter', name, 1, 'toutiao');
      metric.should.deepEqual([
        'emit', 'counter', `toutiao.${name}`, '1', '', ''
      ]);
    });
  });
});