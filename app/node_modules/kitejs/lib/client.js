"use strict";
/**
 * @author xiangshouding
 * @date 2017-07-06 14:34:17
 */
exports.__esModule = true;
var debug_ = require("debug");
var path_1 = require("path");
var compose = require("koa-compose");
var config_1 = require("./config");
var protocol_1 = require("./protocol/protocol");
var http_1 = require("./protocol/http");
var thrift_1 = require("./protocol/thrift");
var random_1 = require("./balance/random");
var logger_1 = require("@byted/logger");
var util = require("./util");
var debug = debug_('client');
var Client = (function () {
    function Client(options, idc, ctx) {
        this.provider = {};
        this.config = new config_1.Config(options, idc, ctx);
        this.register('HTTP', http_1.Http);
        this.register('THRIFT', thrift_1.Thrift);
        this.logger = new logger_1.Logger({
            logFile: this.config.getLogFile(),
            level: this.config.getLogLevel()
        });
        return this;
    }
    /**
     *
     * @param options
     * @param cb
     */
    Client.prototype.request = function (options, cb) {
        if (Object.prototype.toString.call(options) != '[object Object]') {
            cb = options;
            options = {};
        }
        var handle = this.provider[this.config.getProtocol()];
        if (!handle) {
            return cb(new Error("protocol " + this.config.getProtocol() + " not support"), null);
        }
        var __this = this;
        options['timeout'] = this.config.options['timeout'];
        options['service'] = this.service;
        options = this.filter(options);
        var taskHandler = function (order, max) {
            var record = {
                cmd: '',
                addr: '',
                retry: order + '/' + max,
                error: '',
                logId: __this.config.log.logId
            };
            return function (ctx, go) {
                ctx.idx++;
                var next = function (err) {
                    if (ctx.idx === max) {
                        return cb(err, null);
                    }
                    else {
                        return go();
                    }
                };
                __this.config.getHosts(function (err, hosts) {
                    if (err) {
                        record.cmd = 'HOST_FEATCH_FAILED';
                        record.error = err.message;
                        __this.logger.fatal(__this.logToString(record));
                        return next(err);
                    }
                    var addr = __this.getAddress(hosts);
                    var host = addr.getHost(), port = addr.getPort();
                    record.cmd = 'REQUEST_SERVICE_START';
                    record.addr = addr.getAddress();
                    __this.logger.notice(__this.logToString(record));
                    var client = new handle(addr, options);
                    client.request(function (err, service, conn) {
                        if (err) {
                            record.cmd = 'REQUEST_SERVICE_FAILED';
                            record.error = err.message;
                            __this.logger.fatal(__this.logToString(record));
                            return next(err);
                        }
                        // log
                        record.cmd = 'REQUEST_SERVICE_SUCCESS';
                        record.error = '';
                        __this.logger.notice(__this.logToString(record));
                        cb(err, service, conn);
                    });
                });
            };
        };
        var task = [], i = 0;
        do {
            i++;
            task.push(taskHandler(i, this.config.retry));
        } while (i < this.config.retry);
        return compose(task)({ idx: 0 })["catch"](cb);
    };
    Client.prototype.loadService = function (genPath) {
        if (path_1.resolve(genPath)) {
            this.service = require(genPath);
        }
        return this;
    };
    Client.prototype.register = function (protocol, handle) {
        this.provider[protocol] = handle;
    };
    Client.prototype.filter = function (mapA) {
        var mapB = {};
        Object.keys(mapA).filter(function (key) {
            if (mapA[key]) {
                mapB[key] = mapA[key];
            }
        });
        return mapB;
    };
    /**
     * chioce a host from hosts list.
     *
     * @param hosts
     */
    Client.prototype.getAddress = function (hosts) {
        var balance_ = this.config.balance || 'random';
        switch (balance_) {
            case 'random':
                return random_1.random(hosts);
            case 'rate_with_idc':
                return require('./balance/rateWithIDC')(this.config.getHostsWithIDC());
            default:
                return new protocol_1.Address();
        }
    };
    Client.prototype.logToString = function (obj) {
        var log = '';
        var common = {
            protocol: this.config.getProtocol(),
            service: typeof this.config.service == 'string' ? this.config.service : '-',
            time: Date.now()
        };
        util.forEachObject(util.assign(common, obj), function (value, key) {
            log += key + "=[" + value + "] ";
        });
        return log;
    };
    return Client;
}());
exports.Client = Client;
