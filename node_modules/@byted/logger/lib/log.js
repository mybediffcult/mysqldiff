/**
 * byted.org
 *
 * @author xiangshouding
 */

'use strict';

const _ = require('util');
const EventEmitter = require('events');
const caller = require('caller');
const moment = require('moment');
const assert = require('assert');
const {dirname, sep} = require('path');
const {existsSync, mkdirSync, createWriteStream} = require('fs');

const E_NOTICE =  1;
const E_DEBUG = 2;
const E_WARN = 4;
const E_FATAL = 8;
const E_ALL = 15;

class Logger extends EventEmitter {

    constructor(options) {
        super();
        // must a absolute path
        if (options['logFile']) {
            
            assert(typeof options['logFile'] === 'string', 'options.logFile must a string');
            assert(options['logFile'].indexOf('/') === 0, 'logFile must absolute path');

            this.logDirRoot = dirname(options['logFile']);
            if (!existsSync(this.logDirRoot)) {
                this.mkdirP(this.logDirRoot);
            }
            
            this.createStream(options['logFile']);
            
        } else if (options['stream'] && options['streamWf']) {
            this.stream = options['stream'];
            this.streamWf = options['streamWf'];
        } else {
            throw new Error('must given `logFile` or `stream`');
        }

        this.level = options['level'] || E_ALL;
        
        var __this = this;

        ['notice', 'debug', 'warn', 'fatal'].forEach(function (fn) {
            __this.on(fn, __this.to(fn)); 
        });
    }

    to(fn) {
        var __this = this;
        return function (...args) {
            __this[fn](...args);
        };
    }

    createStream(logFile) {
        const defaultOptions = {
            flags: 'a'
        };

        this.stream = createWriteStream(logFile, defaultOptions);
        this.streamWf = createWriteStream(logFile + '.wf', defaultOptions);
    }

    write(stream, data) {
        stream.write(data);
    }

    mkdirP(dir) {
        var pathSplit = dir.split(sep);
        pathSplit.reduce((prefix, sub) => {
            let path = `${prefix}${sep}${sub}`;
            if (path === '/') {
                return path;
            }

            if (!existsSync(path)) {
                mkdirSync(path);
            }

            return path;
        }, '');
    }

    logging(tag, level, format, ...args) {
        if (!(this.level & level)) {
            return;
        }

        var append = this.getLogString();
        
        if (this.isAccess()) {
            append = '';
        }

        if (format instanceof Error) {
            format = format.stack; 
        }

        args = args.map((arg) => {
            if (arg instanceof Error) {
                return arg.stack;
            }

            return arg;
        });

        format = `[${tag}] ${moment().format('YYYY-MM-DD HH:mm:ss')} ${append} ${format}\n`;

        let stream = (level & (E_FATAL | E_WARN)) ? this.streamWf : this.stream;
        this.write(stream, _.format(format, ...args));
    }

    notice(format, ...args) {
        return this.logging('NOTICE', E_NOTICE, format, ...args);
    }

    debug(format, ...args) {
        return this.logging('DEBUG', E_DEBUG, format, ...args);
    }

    warn(format, ...args) {
        return this.logging('WARN', E_WARN, format, ...args);
    }

    fatal(format, ...args) {
        return this.logging('FATAL', E_FATAL, format, ...args);
    }

    access() {
        var log = `${moment().format('YYYY-MM-DD HH:mm:ss')} ${this.getLogString()}\n`;
        this.write(this.stream, log);
    }

    getLogString() {
        return '';
    }

    isAccess() {
        return false;
    }
}

function logFileByCaller(){
    return dirname(caller(2)) + '/logger.log'
}

module.exports = function logger() {
    return new Logger({
        logFile: logFileByCaller(),
        level: E_ALL
    });
}

module.exports.Logger = Logger;
module.exports.E_ALL = E_ALL;
module.exports.E_NOTICE = E_NOTICE;
module.exports.E_DEBUG = E_DEBUG;
module.exports.E_WARN = E_WARN;
module.exports.E_FATAL = E_FATAL;
