const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const upperCamelCase = require('uppercamelcase');
const cls = require('cls-hooked');
const Consul = require('../consul/consul');

class SequelizeCreator {
    constructor(options) {
        this.consul = new Consul(options.consul);
    }

    /**
     * 使用CLS
     * @param {String} namespace - 命名空间
     */
    useCLS(namespace = 'default') {
        Sequelize.useCLS(cls.createNamespace(namespace));
    }

    /**
     * 创建Sequelize实例
     * 
     * @param {Object} config - Sequelize实例配置
     */
    async create(config) {
        let options = config.options;
        if (options.psm) {
            const address = await this.consul.random(options.psm);
            options.host = address.host;
            options.port = address.port;
        }
        if (options.replication) {
            const { read, write } = options.replication;
            if (!(read instanceof Array)) {
                throw new Error('Sequelize\'s replication read config must be an array.');
            }
            if (!write || typeof write !== 'object') {
                throw new Error('Sequelize\'s replication write config must be an object.');
            }

            const readClients = [];
            for (var i = 0; i < read.length; i++) {
                const item = read[i];
                if (item.psm) {
                    const addresses = await this.consul.lookup(item.psm);
                    addresses.forEach(address => {
                        readClients.push({ 
                            host: address.host, 
                            port: address.port, 
                            username: item.username, 
                            password: item.password 
                        });
                    });
                } else {
                    readClients.push(item)
                }
            }

            const writeClient = { username: write.username, password: write.password };
            if (write.psm) {
                const address = await this.consul.random(write.psm);
                writeClient.host = address.host;
                writeClient.port = address.port; 
            }
            options.replication = {
                read: readClients,
                write: writeClient
            };
        }

        options = Object.assign({}, {
            dialect: 'mysql',
            define: {
                freezeTableName: true,
                timestamps: true,
            },
            timezone: '+08:00',
            logging: false
        }, options);

        const sequelize = new Sequelize(config.name, config.username, config.password, options);

        if (config.modelDir) {
            const modelDir = config.modelDir;
            const models = [];
            fs.readdirSync(modelDir).forEach(file => {
                const model = sequelize.import(path.resolve(modelDir, file));
                sequelize[upperCamelCase(model.name)] = model;
                models.push(model);
            });
            models.forEach(model => {
                if (model.associate) {
                    model.associate(sequelize);
                }                
            });
        }           
        
        return sequelize;
    }
}

SequelizeCreator.Sequelize = Sequelize;

module.exports = SequelizeCreator;