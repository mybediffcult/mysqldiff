/**
 * A library for emitting and collecting metrics.
 * 
 * @author Yaphet Ye <yeyuanfeng@bytedance.com>
 */

'use strict';

const fs = require('fs');
const dgram = require('dgram');
const assert = require('assert');
const msgpack = require('msgpack');

const DEFAULT_PREFIX = 'toutiao';
const DEFAULT_FLUSH_INTERVAL = 30 * 1000;
const MAX_BUFFER_SIZE = 500;
const DEFAULT_OPTIONS = {
    host: '127.0.0.1',
    port: 9123,
    defaultPrefix: DEFAULT_PREFIX,
    bufferSize: 1,
    flushInterval: DEFAULT_FLUSH_INTERVAL
};

function assertMetricType(metricType, message) {
    assert(
        ['counter', 'timer', 'store'].indexOf(metricType) !== -1,
        message || `invalid argument metricType: ${metricType}, 'couter', 'timer' or 'store' are expected`
    );
}

function assertMetricName(name, message) {
    assert(name && typeof name === 'string', message || `invalid argument name: ${name}, a non-empty string is expected`)
}

function assertMetricValue(value, message) {
    assert(value || value === 0 || value === '0', message || `invalid argument value: ${value}, a non-empty value is expected`);
}

function assertMetric(metric) {
    assert(metric instanceof Array, `invalid argument metric: ${metric}, an array is expected`);
    assert(metric.length === 6, `invalid argument metric: ${metric}, length is expected to be 6`);
    assert(metric[0] === 'emit', `invalid argument metric: ${metric}, element at index 0 is expected to be 'emit'`);
    assertMetricType(metric[1], `invalid argument metric: ${metric}, element at index 1 is expected to be 'couter', 'timer' or 'store'`);
    assertMetricName(metric[2], `invalid argument metric: ${metric}, element at index 2 is expected to be non-empty`);
    assertMetricValue(metric[3], `invalid argument metric: ${metric}, element at index 3 is expected to be non-empty`);
}

class Metrics {
    constructor(options = DEFAULT_OPTIONS) {
        this._options = Object.assign({}, DEFAULT_OPTIONS, options);
        if (this._options.bufferSize > MAX_BUFFER_SIZE) {
            this._options.bufferSize = MAX_BUFFER_SIZE;
        }
        this._buffer = [];
        this._lastFlushedTime = new Date().getTime();
    }

    /**
     * Emit counter metric
     * 
     * @param {String} name 
     * @param {String | Number} value 
     * @param {String} prefix 
     * @param {Object} tags 
     * @return {Promise<void>}
     */
    emitCounter(name, value, prefix, tags) {
        return this._emit('counter', name, value, prefix, tags);
    }

    /**
     * Emit timer metric
     * 
     * @param {String} name 
     * @param {String | Number} value 
     * @param {String} prefix 
     * @param {Object} tags 
     * @return {Promise<void>}
     */
    emitTimer(name, value, prefix, tags) {
        return this._emit('timer', name, value, prefix, tags);
    }

    /**
     * Emit store metric
     * 
     * @param {String} name 
     * @param {String | Number} value 
     * @param {String} prefix 
     * @param {Object} tags 
     * @return {Promise<void>}
     */
    emitStore(name, value, prefix, tags) {
        return this._emit('store', name, value, prefix, tags);
    }

    /**
     * Emit a metric to server
     * 
     * @param {String} metricType 'counter' | 'timer' | 'store'
     * @param {String} name 
     * @param {String} value 
     * @param {String} prefix 
     * @param {Object} tags 
     * @return {Promise<void>}
     */
    _emit(metricType, name, value, prefix, tags) {
        const metric = this._getMetric(metricType, name, value, prefix, tags);
        this._addToBuffer(metric);
        return this._flushIfNeeded(metricType);
    }

    /**
     * Get metric data
     * 
     * @param {String} metricType 'counter' | 'timer' | 'store'
     * @param {String} name 
     * @param {String | Number} value 
     * @param {String} prefix 
     * @param {Object} tags 
     */
    _getMetric(metricType, name, value, prefix, tags) {
        assertMetricType(metricType);
        assertMetricName(name);
        assertMetricValue(value);

        const prefixedName = this._getPrefixedName(name, prefix);
        const serializedTags = this._serializeTags(tags || {});
        const metric = ['emit', metricType, prefixedName, value.toString(), serializedTags, ''];
        return metric;
    }

    /**
     * prefix metric name 
     * 
     * @param {String} name 
     * @param {String} prefix 
     * @return {String}
     */
    _getPrefixedName(name, prefix) {
        return `${prefix || this._options.defaultPrefix}.${name}`;
    }

    /**
     * Serialize tags object
     * 
     * @param {Object} tags 
     * @return {String}
     */
    _serializeTags(tags) {
        assert(
            tags && typeof tags === 'object' && !(tags instanceof Array),
            `invalid argument tags: ${tags}, an object is expected`
        );

        return Object.keys(tags).filter((k) => tags.hasOwnProperty(k)).map(k => {
            return `${k}=${tags[k]}`;
        }).join('|');
    }

    /**
     * Add a metric to buffer
     * 
     * @param {Metric} metric 
     * @return {void}
     */
    _addToBuffer(metric) {
        assertMetric(metric);
        this._buffer.push(metric);
    }

    /**
     * Flush metrics buffer if current buffer size is greater than specified bufferSize. 
     * 
     * @return {Promise<void> | Undefined}
     */
    _flushIfNeeded() {
        const now = new Date().getTime();
        if (this._buffer.length >= this._options.bufferSize
            || (now - this._lastFlushedTime) >= this._options.flushInterval) {
            if (this.timer) {
                this.timer && clearTimeout(this.timer);
                this.timer = 0;
            }
            return this._flush();
        }
        else if (this._buffer.length > 0 && !this.timer) {
            this.timer = setTimeout(() => {
                this._flushIfNeeded();
            }, this._options.flushInterval);
        }
    }

    /**
     * Flush metrics buffer
     *    
     * @return {Promise<void>}
     */
    _flush() {
        const metrics = this._buffer;
        this._buffer = [];
        this._lastFlushedTime = new Date().getTime();
        return this._send(metrics);
    }

    /**
     * Send metrics
     * 
     * @param {Array<Metric>} metrics array of metric
     * @return {Promise<void>}
     */
    _send(metrics) {
        assert(metrics instanceof Array, `invalid argument metrics: ${metrics}, an array is expected`);

        return new Promise((resolve, reject) => {
            const client = dgram.createSocket('udp4');
            const buffer = msgpack.pack(metrics);
            client.send(buffer, 0, buffer.length, this._options.port, this._options.host, (err) => {
                client.close();
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
}

module.exports = Metrics;